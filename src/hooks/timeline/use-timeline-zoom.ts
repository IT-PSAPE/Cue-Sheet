import { useCallback, useEffect, useRef, useState } from 'react'
import { MIN_ZOOM, MAX_EFFECTIVE_ZOOM, ZOOM_FACTOR, BASE_PIXELS_PER_MINUTE } from '@/utils/timeline/timeline-constants'

interface UseTimelineZoomOptions {
  totalMinutes: number
  timelineContainer: HTMLDivElement | null
  currentTimeMinutesRef: React.RefObject<number>
  onPinchStateChange?: (isActive: boolean) => void
}

export function useTimelineZoom({ totalMinutes, timelineContainer, currentTimeMinutesRef, onPinchStateChange }: UseTimelineZoomOptions) {
  const [zoom, setZoom] = useState(1)
  const [containerWidth, setContainerWidth] = useState(0)

  const fitZoom = containerWidth > 0 ? containerWidth / (totalMinutes * BASE_PIXELS_PER_MINUTE) : 1
  const maxZoom = Math.max(MIN_ZOOM, MAX_EFFECTIVE_ZOOM / fitZoom)
  const clampedZoom = Math.min(maxZoom, Math.max(MIN_ZOOM, zoom))
  const effectiveZoom = fitZoom * clampedZoom
  const pixelsPerMinute = BASE_PIXELS_PER_MINUTE * effectiveZoom

  const fitZoomRef = useRef(fitZoom)
  fitZoomRef.current = fitZoom
  const maxZoomRef = useRef(maxZoom)
  maxZoomRef.current = maxZoom
  const currentZoomRef = useRef(clampedZoom)
  const pinchLastDistanceRef = useRef<number | null>(null)
  const activeTouchPointsRef = useRef<Map<number, { clientX: number; clientY: number }>>(new Map())

  useEffect(() => {
    currentZoomRef.current = clampedZoom
  }, [clampedZoom])

  // Track container width with ResizeObserver
  useEffect(() => {
    if (!timelineContainer) return

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setContainerWidth(entry.contentRect.width)
      }
    })

    observer.observe(timelineContainer)
    setContainerWidth(timelineContainer.clientWidth)
    return () => observer.disconnect()
  }, [timelineContainer])

  const updateZoomAnchoredToPlayhead = useCallback(
    (direction: 'in' | 'out') => {
      if (!timelineContainer) return

      const scrollLeftBeforeZoom = timelineContainer.scrollLeft
      const time = currentTimeMinutesRef.current

      setZoom((z) => {
        const currentZoom = Math.min(maxZoomRef.current, Math.max(MIN_ZOOM, z))
        const currentEffectiveZoom = fitZoomRef.current * currentZoom
        const playheadViewportX = time * BASE_PIXELS_PER_MINUTE * currentEffectiveZoom - scrollLeftBeforeZoom

        const nextRawZoom = direction === 'in' ? currentZoom * ZOOM_FACTOR : currentZoom / ZOOM_FACTOR
        const clampedRawZoom = Math.min(maxZoomRef.current, Math.max(MIN_ZOOM, nextRawZoom))
        const nextEffectiveZoom = fitZoomRef.current * clampedRawZoom

        requestAnimationFrame(() => {
          const playheadTimelineXAfterZoom = time * BASE_PIXELS_PER_MINUTE * nextEffectiveZoom
          const targetScrollLeft = playheadTimelineXAfterZoom - playheadViewportX
          const maxScrollLeft = Math.max(0, timelineContainer.scrollWidth - timelineContainer.clientWidth)
          timelineContainer.scrollLeft = Math.min(maxScrollLeft, Math.max(0, targetScrollLeft))
        })

        return clampedRawZoom
      })
    },
    [timelineContainer, currentTimeMinutesRef]
  )

  const setZoomAnchoredToPlayhead = useCallback(
    (nextRawZoom: number) => {
      if (!timelineContainer) return

      const scrollLeftBeforeZoom = timelineContainer.scrollLeft
      const time = currentTimeMinutesRef.current

      setZoom((z) => {
        const currentZoom = Math.min(maxZoomRef.current, Math.max(MIN_ZOOM, z))
        const currentEffectiveZoom = fitZoomRef.current * currentZoom
        const playheadViewportX = time * BASE_PIXELS_PER_MINUTE * currentEffectiveZoom - scrollLeftBeforeZoom
        const clampedRawZoom = Math.min(maxZoomRef.current, Math.max(MIN_ZOOM, nextRawZoom))
        const nextEffectiveZoom = fitZoomRef.current * clampedRawZoom

        requestAnimationFrame(() => {
          const playheadTimelineXAfterZoom = time * BASE_PIXELS_PER_MINUTE * nextEffectiveZoom
          const targetScrollLeft = playheadTimelineXAfterZoom - playheadViewportX
          const maxScrollLeft = Math.max(0, timelineContainer.scrollWidth - timelineContainer.clientWidth)
          timelineContainer.scrollLeft = Math.min(maxScrollLeft, Math.max(0, targetScrollLeft))
        })

        return clampedRawZoom
      })
    },
    [timelineContainer, currentTimeMinutesRef]
  )

  // Wheel handler: Ctrl/Cmd+scroll = zoom, Shift+scroll = horizontal scroll
  useEffect(() => {
    if (!timelineContainer) return

    const handleWheel = (e: WheelEvent) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault()
        updateZoomAnchoredToPlayhead(e.deltaY > 0 ? 'out' : 'in')
      } else if (e.shiftKey) {
        e.preventDefault()
        timelineContainer.scrollLeft += e.deltaY
      }
    }

    timelineContainer.addEventListener('wheel', handleWheel, { passive: false })
    return () => timelineContainer.removeEventListener('wheel', handleWheel)
  }, [updateZoomAnchoredToPlayhead, timelineContainer])

  // Pinch-to-zoom on touch devices using two active touch pointers.
  useEffect(() => {
    if (!timelineContainer) return

    const getDistance = () => {
      const points = Array.from(activeTouchPointsRef.current.values())
      if (points.length < 2) return null
      const [first, second] = points
      return Math.hypot(second.clientX - first.clientX, second.clientY - first.clientY)
    }

    const resetPinch = () => {
      pinchLastDistanceRef.current = null
      onPinchStateChange?.(false)
    }

    const handlePointerDown = (event: PointerEvent) => {
      if (event.pointerType !== 'touch') return
      activeTouchPointsRef.current.set(event.pointerId, { clientX: event.clientX, clientY: event.clientY })

      if (activeTouchPointsRef.current.size === 2) {
        pinchLastDistanceRef.current = getDistance()
        onPinchStateChange?.(true)
      }
    }

    const handlePointerMove = (event: PointerEvent) => {
      if (event.pointerType !== 'touch') return
      if (!activeTouchPointsRef.current.has(event.pointerId)) return

      activeTouchPointsRef.current.set(event.pointerId, { clientX: event.clientX, clientY: event.clientY })
      if (activeTouchPointsRef.current.size < 2) return

      const previousDistance = pinchLastDistanceRef.current
      const currentDistance = getDistance()
      if (!previousDistance || !currentDistance) return
      if (previousDistance < 8) return

      const distanceRatio = currentDistance / previousDistance
      const nextZoom = currentZoomRef.current * distanceRatio
      setZoomAnchoredToPlayhead(nextZoom)
      pinchLastDistanceRef.current = currentDistance
      event.preventDefault()
    }

    const handlePointerUpOrCancel = (event: PointerEvent) => {
      if (event.pointerType !== 'touch') return
      activeTouchPointsRef.current.delete(event.pointerId)

      if (activeTouchPointsRef.current.size < 2) {
        resetPinch()
      } else {
        pinchLastDistanceRef.current = getDistance()
      }
    }

    const previousTouchAction = timelineContainer.style.touchAction
    timelineContainer.style.touchAction = 'pan-x pan-y'

    timelineContainer.addEventListener('pointerdown', handlePointerDown)
    timelineContainer.addEventListener('pointermove', handlePointerMove, { passive: false })
    timelineContainer.addEventListener('pointerup', handlePointerUpOrCancel)
    timelineContainer.addEventListener('pointercancel', handlePointerUpOrCancel)
    timelineContainer.addEventListener('pointerleave', handlePointerUpOrCancel)

    return () => {
      timelineContainer.style.touchAction = previousTouchAction
      timelineContainer.removeEventListener('pointerdown', handlePointerDown)
      timelineContainer.removeEventListener('pointermove', handlePointerMove)
      timelineContainer.removeEventListener('pointerup', handlePointerUpOrCancel)
      timelineContainer.removeEventListener('pointercancel', handlePointerUpOrCancel)
      timelineContainer.removeEventListener('pointerleave', handlePointerUpOrCancel)
      activeTouchPointsRef.current.clear()
      resetPinch()
    }
  }, [onPinchStateChange, setZoomAnchoredToPlayhead, timelineContainer])

  return {
    zoom,
    clampedZoom,
    fitZoom,
    maxZoom,
    effectiveZoom,
    pixelsPerMinute,
    containerWidth,
    updateZoomAnchoredToPlayhead,
    setZoomAnchoredToPlayhead,
  }
}
